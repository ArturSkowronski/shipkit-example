static String commitMessage(String message) {
    def buildNo = System.env.TRAVIS_BUILD_NUMBER
    if (buildNo) {
        return message + " by Travis CI build $System.env.TRAVIS_BUILD_NUMBER [ci skip]"
    } else {
        return message + " [ci skip]"
    }
}

task gitAddBumpVersion(type: Exec) {
    description = "Performs 'git add' for the version properties file"
    mustRunAfter tasks.bumpVersionFile
    commandLine = ["git", "add", "version.properties"]
}

task gitAddReleaseNotes(type: Exec) {
    description = "Performs 'git add' for the release notes file"
    mustRunAfter tasks.updateReleaseNotes
    doFirst { //so that we can access user-configured 'releaseNotesFile' property
        commandLine = ["git", "add", notes.releaseNotesFile]
    }
}

task gitCommit(type: Exec) {
    description = "Commits staged changes using generic --author"
    mustRunAfter tasks.gitAddBumpVersion, tasks.gitAddReleaseNotes
    doFirst {
        commandLine = ["git", "commit", "--author", "$project.ext.genericGitUserName <$project.ext.genericGitUserEmail>",
                       "-m", commitMessage("Bumped version and updated release notes")]
    }
}

task gitTag(type: Exec) {
    description = "Creates new version tag 'v${project.version}'"
    commandLine "git", "tag", "-a", "v${project.version}", "-m", commitMessage("Created new tag v${project.version}")
}

ext.envVar = { String name ->
    def envValue = System.getenv(name)
    if (!envValue) {
        throw new GradleException("Please export '$name' env variable first!")
    }
    envValue
}

task gitPush {
    description = "Pushes changes to remote repo."

    mustRunAfter gitCommit, gitTag

    doFirst {
        //!!!We are using 'exec' method and not Exec task on purpose so that there is no risk of exposing the token!
        //!!!For exampleExec task can be configured with doFirst() to print all command line parameters
        exec {
            //!!!Below command _MUST_ be quiet otherwise it exposes GitHub write token!!!
            def mustBeQuiet = "-q"
            commandLine = ["git", "push",
                           "https://${project.ext.gitHubUser}:${envVar('GH_TOKEN')}@github.com/${notes.gitHubRepository}.git",
                           envVar('TRAVIS_BRANCH'), "v$project.version", mustBeQuiet]
            if (rootProject.ext.has('releaseDryRun')) {
                logger.lifecycle "  Running 'git push' with '--dry-run' in quiet mode."
                commandLine += ['--dry-run']
                assert commandLine.contains('--dry-run') //paranoia, I love Groovy
            }
            //!!!We must capture and hide the output because when git push fails it can expose the token!
            def output = new ByteArrayOutputStream()
            standardOutput = output
            errorOutput = output
        }
    }
}

task bintrayUploadAll {
    description = "Depends on all 'bintrayUpload' tasks from all Gradle projects."
}

task performRelease {
    description = "Performs release. To test release use './gradlew testRelease'"

    dependsOn bumpVersionFile, updateReleaseNotes
    dependsOn gitAddBumpVersion, gitAddReleaseNotes, gitCommit, gitTag
    dependsOn gitPush
    dependsOn bintrayUploadAll
}

task gitCommitCleanUp(type: Exec) {
    description = "Removes last commit, using 'reset --hard HEAD~'"
    mustRunAfter performRelease
    commandLine = ["git", "reset", "--hard", "HEAD~"]
}

task gitTagCleanUp(type: Exec) {
    description = "Deletes version tag 'v$project.version'"
    mustRunAfter performRelease
    commandLine = ["git", "tag", "-d", "v$project.version"]
}

task releaseCleanUp {
    description = "Cleans up the working copy, useful after dry running the release"
    //using finalizedBy so that all clean up tasks run, even if one of them fails
    finalizedBy gitCommitCleanUp
    finalizedBy gitTagCleanUp
}

task gitUnshallow(type: Exec) {
    //Travis default clone is shallow which will prevent correct release notes generation for repos with lots of commits
    commandLine "git", "fetch", "--unshallow"

    description = "Performs '${commandLine.join(' ')}' to ensure good chunk of recent commits is available for release notes automation"

    ignoreExitValue = true
    doLast {
        if (execResult.exitValue != 0) {
            logger.lifecycle "  Following git command failed and will be ignored:" +
                    "\n    \"${commandLine.join(' ')}\"" +
                    "\n  Most likely the repository already contains all history"
        }
    }
}

task checkOutBranch(type: Exec) {
    description = "Checks out the branch that can be committed. CI systems often check out revision that is not committable."
    doFirst { //using doFirst() so that we request and validate presence of env var only during execution time
        commandLine = ["git", "checkout", envVar('TRAVIS_BRANCH')]
    }
}

task configureGitUserName(type: Exec) {
    description = "Overwrites local git 'user.name' with a generic name. Intended for Travis CI."
    doFirst {
        commandLine = ["git", "config", "--local", "user.name", project.ext.genericGitUserName]
    }
}

task configureGitUserEmail(type: Exec) {
    description = "Overwrites local git 'user.email' with a generic email. Intended for Travis CI."
    doFirst {
        commandLine = ["git", "config", "--local", "user.email", project.ext.genericGitUserEmail]
    }
}

tasks.withType(Exec) {
    doFirst {
        def command = commandLine.join(" ").trim()
        if (command != "null") { //Groovy/Gradle weirdness. Don't ask...
            //why the 'if' statement here?
            //sometimes we use doFirst() to configure the commandLine and hence the command line is empty (null)
            //we don't want to print null
            logger.lifecycle "  Running:\n    " + commandLine.join(" ")
        }
    }
}

task travisReleasePrepare {
    description = "Prepares the working copy for releasing using Travis CI"
    dependsOn gitUnshallow, checkOutBranch, configureGitUserName, configureGitUserEmail
}

static boolean isPullRequest() {
    //returns true only if pull request env variable points to PR number
    def envVar = System.env.TRAVIS_PULL_REQUEST
    envVar != null && envVar != '' && envVar != 'false'
}

task releaseNeeded {
    description = "Checks if the criteria for the release are met."
    doLast {
        def skipEnvVariable = System.env.SKIP_RELEASE
        def skippedByCommitMessage = System.env.TRAVIS_COMMIT_MESSAGE?.contains('[ci skip-release]')
        def pullRequest = isPullRequest()
        def releasableBranch = System.env.TRAVIS_BRANCH?.matches(project.ext.releasableBranchRegex)

        if (skipEnvVariable || skippedByCommitMessage || pullRequest || !releasableBranch) {
            ext.needed = false
        } else {
            ext.needed = true
        }

        logger.lifecycle("""  Release is needed: $needed
    - skip by env variable: $skipEnvVariable
    - skip by commit message: $skippedByCommitMessage
    - is pull request build: $pullRequest
    - is releasable branch: $releasableBranch""")
    }
}

task travisRelease {
    description = "Performs the release if release criteria are met, intended to be used by Travis CI job"

    dependsOn releaseNeeded
    onlyIf {
        releaseNeeded.didWork && releaseNeeded.needed
        //also checking didWork so that we can "-x releaseNeeded" to force the release without criteria check
    }

    doLast {
        //first, we need to prepare Travis working copy
        exec { commandLine "./gradlew", "travisReleasePrepare" }
        //then, we will do the full release with dry run to flesh out any issues
        performReleaseTest()
        //finally, let's make the release!
        exec { commandLine "./gradlew", "performRelease" }
        //perform notable release if needed
        performNotableRelease(false)
    }
}

void performNotableRelease(boolean dryRun) {
    def v = project.version.toString()
    if (v.endsWith(".0") || v.endsWith(".0.0")) { //new minor or major version
        logger.lifecycle "  It looks like we are releasing a new notable version!\n" +
                "  Performing additional upload to 'notable versions' repository and Maven Central."

        exec {
            commandLine "./gradlew", "bintrayUploadAll",
                    "-Prelease_version=$v",
                    "-Pbintray_repo=mockito-release-tools-example-repo-notable",
                    "-Pbintray_mavenCentralSync"
            if (dryRun) {
                commandLine += "-PreleaseDryRun"
            }
        }
    } else {
        logger.lifecycle "  Version '$v' is not a notable version.\n" +
                "  NO additional upload to 'notable versions' repository and NO sync to Maven Central."
    }
}

void performReleaseTest() {
    exec { commandLine "./gradlew", "performRelease", "releaseCleanUp", "-PreleaseDryRun" }
}

task testRelease {
    description = "Tests the release, intended to be used locally by engineers"
    doLast { performReleaseTest() }
}

task testNotableRelease {
    description = "Tests the notable release, intended to be used locally by engineers"

    doLast { performNotableRelease(true) }
}